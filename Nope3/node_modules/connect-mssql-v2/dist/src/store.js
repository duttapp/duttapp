"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const mssql_1 = __importStar(require("mssql"));
const express_session_1 = require("express-session");
class MSSQLStore extends express_session_1.Store {
    constructor(config, options) {
        super();
        this.table = (options === null || options === void 0 ? void 0 : options.table) || 'sessions';
        this.ttl = (options === null || options === void 0 ? void 0 : options.ttl) || 1000 * 60 * 60 * 24;
        this.autoRemove = (options === null || options === void 0 ? void 0 : options.autoRemove) || false;
        this.autoRemoveInterval = (options === null || options === void 0 ? void 0 : options.autoRemoveInterval) || 1000 * 60 * 10;
        this.autoRemoveCallback = (options === null || options === void 0 ? void 0 : options.autoRemoveCallback) || undefined;
        this.useUTC = (options === null || options === void 0 ? void 0 : options.useUTC) || true;
        this.config = config;
        this.databaseConnection = new mssql_1.default.ConnectionPool(config);
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Initializes connection to the database and emits connect on success or error on failure
     */
    // ////////////////////////////////////////////////////////////////
    async initializeDatabase() {
        // Attachs connect event listener and emits on successful connection
        this.databaseConnection.on('connect', () => this.emit('connect', this));
        // Attachs error event listener and emits on failed connection
        this.databaseConnection.on('error', (error) => this.emit('error', error));
        await this.databaseConnection.connect();
        this.databaseConnection.emit('connect');
        if (this.autoRemove) {
            setInterval(() => this.destroyExpired(this.autoRemoveCallback), this.autoRemoveInterval);
        }
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Verifies database connection has been established, and if not, will initialize connection
     */
    // ////////////////////////////////////////////////////////////////
    async dbReadyCheck() {
        var _a;
        try {
            if (!this.databaseConnection.connected && !this.databaseConnection.connecting) {
                await this.initializeDatabase();
            }
            if ((_a = this.databaseConnection) === null || _a === void 0 ? void 0 : _a.connected) {
                return true;
            }
            throw new Error('Connection is closed.');
        }
        catch (error) {
            this.databaseConnection.emit('error', error);
            throw error;
        }
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Verify session.cookie.expires is not a boolean. If so, use current time along with
     * ttl else return session.cookie.expires
     * @param sessionCookie
     */
    // ////////////////////////////////////////////////////////////////
    getExpirationDate(sessionCookie) {
        const isExpireBoolean = !!sessionCookie && typeof sessionCookie.expires === 'boolean';
        const expires = new Date(isExpireBoolean || !(sessionCookie === null || sessionCookie === void 0 ? void 0 : sessionCookie.expires) ? Date.now() + this.ttl : sessionCookie.expires);
        return expires;
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Runs the provided query statement against the database.
     * Returns T if expectReturn is true else returns null
     * @param props
     */
    // ////////////////////////////////////////////////////////////////
    async queryRunner(props) {
        const isReady = await this.dbReadyCheck();
        if (!isReady) {
            throw new Error('Database connection is closed');
        }
        const request = await this.databaseConnection.request();
        const { inputParameters, expectReturn, queryStatement } = props;
        /**
         * If any inputParamters exist, attach to request object
         */
        Object.entries(inputParameters !== null && inputParameters !== void 0 ? inputParameters : {}).forEach(([key, { value, dataType }]) => {
            request.input(key, dataType, value);
        });
        /**
         * Run query against database
         */
        const result = await request.query(queryStatement);
        return expectReturn ? result.recordset : null;
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Attachs sessionError event listener and emits on error on any
     * store error and includes method where error occured
     * @param method
     * @param error
     * @param callback
     */
    // ////////////////////////////////////////////////////////////////
    errorHandler(method, error, callback) {
        // eslint-disable-next-line no-shadow
        this.databaseConnection.once('sessionError', () => this.emit('sessionError', error, method));
        this.databaseConnection.emit('sessionError', error, method);
        return callback ? callback(error) : null;
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Attempt to fetch all sessions
     * @param callback
     */
    // //////////////////////////////////////////////////////////////
    async all(callback) {
        var _a;
        try {
            const queryResult = await this.queryRunner({
                queryStatement: `SELECT sid, session FROM ${this.table}`,
                expectReturn: true,
            });
            const queryResultLength = (_a = queryResult === null || queryResult === void 0 ? void 0 : queryResult.length) !== null && _a !== void 0 ? _a : 0;
            const returnObject = {};
            if (queryResult) {
                for (let i = 0; i < queryResultLength; i += 1) {
                    returnObject[queryResult[i].sid] = JSON.parse(queryResult[i].session);
                }
            }
            callback(null, queryResultLength ? returnObject : null);
        }
        catch (err) {
            this.errorHandler('all', err, callback);
        }
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Attempt to fetch session the given sid
     * @param sid
     * @param callback
     */
    // //////////////////////////////////////////////////////////////
    async get(sid, callback) {
        try {
            const queryResult = await this.queryRunner({
                inputParameters: { sid: { value: sid, dataType: (0, mssql_1.NVarChar)(255) } },
                queryStatement: `SELECT session 
                           FROM ${this.table}
                           WHERE sid = @sid`,
                expectReturn: true,
            });
            callback(null, (queryResult === null || queryResult === void 0 ? void 0 : queryResult.length) ? JSON.parse(queryResult[0].session) : null);
        }
        catch (err) {
            this.errorHandler('get', err, callback);
        }
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Commit the given session object associated with the given sid
     * @param sid
     * @param currentSession
     * @param callback
     */
    // //////////////////////////////////////////////////////////////
    async set(sid, currentSession, callback) {
        try {
            const expires = this.getExpirationDate(currentSession.cookie);
            await this.queryRunner({
                inputParameters: {
                    sid: { value: sid, dataType: (0, mssql_1.NVarChar)(255) },
                    session: { value: JSON.stringify(currentSession), dataType: (0, mssql_1.NVarChar)(mssql_1.MAX) },
                    expires: { value: expires, dataType: mssql_1.DateTime },
                },
                queryStatement: `UPDATE ${this.table} 
                           SET session = @session, expires = @expires 
                           WHERE sid = @sid;
                           IF @@ROWCOUNT = 0 
                            BEGIN
                              INSERT INTO ${this.table} (sid, session, expires)
                                VALUES (@sid, @session, @expires)
                            END;`,
                expectReturn: false,
            });
            if (callback) {
                callback();
            }
        }
        catch (err) {
            this.errorHandler('set', err, callback);
        }
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Update the expiration date of the given sid
     * @param sid
     * @param data
     * @param callback
     */
    // //////////////////////////////////////////////////////////////
    async touch(sid, currentSession, callback) {
        try {
            const expires = this.getExpirationDate(currentSession.cookie);
            await this.queryRunner({
                inputParameters: {
                    sid: { value: sid, dataType: (0, mssql_1.NVarChar)(255) },
                    expires: { value: expires, dataType: mssql_1.DateTime },
                },
                queryStatement: `UPDATE ${this.table} 
                           SET expires = @expires 
                           WHERE sid = @sid`,
                expectReturn: false,
            });
            if (callback) {
                callback();
            }
        }
        catch (err) {
            this.errorHandler('touch', err, callback);
        }
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Destroy the session associated with the given sid
     * @param sid
     * @param callback
     */
    // //////////////////////////////////////////////////////////////
    async destroy(sid, callback) {
        try {
            await this.queryRunner({
                inputParameters: { sid: { value: sid, dataType: (0, mssql_1.NVarChar)(255) } },
                queryStatement: `DELETE FROM ${this.table} 
                           WHERE sid = @sid`,
                expectReturn: false,
            });
            if (callback) {
                callback();
            }
        }
        catch (err) {
            this.errorHandler('destroy', err, callback);
        }
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Destroy expired sessions
     * @param callback
     */
    // //////////////////////////////////////////////////////////////
    async destroyExpired(callback) {
        try {
            await this.queryRunner({
                queryStatement: `DELETE FROM ${this.table} 
                           WHERE expires <= GET${this.useUTC ? 'UTC' : ''}DATE()`,
                expectReturn: false,
            });
            if (this.autoRemoveCallback) {
                this.autoRemoveCallback();
            }
            if (callback) {
                callback();
            }
        }
        catch (err) {
            if (this.autoRemoveCallback) {
                this.autoRemoveCallback(err);
            }
            this.errorHandler('destroyExpired', err, callback);
        }
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Fetch total number of sessions
     * @param callback
     */
    // //////////////////////////////////////////////////////////////
    async length(callback) {
        var _a;
        try {
            const queryResult = await this.queryRunner({
                queryStatement: `SELECT COUNT(sid) AS length
                           FROM ${this.table}`,
                expectReturn: true,
            });
            callback(null, (_a = queryResult === null || queryResult === void 0 ? void 0 : queryResult[0].length) !== null && _a !== void 0 ? _a : 0);
        }
        catch (err) {
            this.errorHandler('length', err, callback);
        }
    }
    // ////////////////////////////////////////////////////////////////
    /**
     * Clear all sessions
     * @param callback
     */
    // //////////////////////////////////////////////////////////////
    async clear(callback) {
        try {
            await this.queryRunner({
                queryStatement: `TRUNCATE TABLE ${this.table}`,
                expectReturn: false,
            });
            if (callback) {
                callback();
            }
        }
        catch (err) {
            this.errorHandler('clear', err, callback);
        }
    }
}
/**
 * 08/30/2021 - JL
 * * To correct an issue where you could not correctly require within a JS file without
 * * targeting the default export, we have added the line below. Should provide non-breaking fix.
 * * Might be modified for future versions with potential breaking change.
 */
module.exports = MSSQLStore;
exports.default = MSSQLStore;
